<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="group__memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">memory </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><img src="https://img.shields.io/endpoint?url=https%3A%2F%2Fwww.jonathanmueller.dev%2Fproject%2Fmemory%2Findex.json" alt="Project Status" class="inline"/> <a href="https://travis-ci.org/foonathan/memory"><img src="https://travis-ci.org/foonathan/memory.svg?branch=master" alt="Build Status" class="inline"/></a> <a href="https://ci.appveyor.com/project/foonathan/memory/branch/master"><img src="https://ci.appveyor.com/api/projects/status/ef654yqyoqgvl472/branch/master?svg=true" alt="Build status" class="inline"/></a> <a href="https://opensource.org/licenses/Zlib"><img src="https://img.shields.io/badge/License-Zlib-lightgrey.svg" alt="License: Zlib" class="inline"/></a></p>
<p>The C++ STL allocator model has various flaws. For example, they are fixed to a certain type, because they are almost necessarily required to be templates. So you can't easily share a single allocator for multiple types. In addition, you can only get a copy from the containers and not the original allocator object. At least with C++11 they are allowed to be stateful and so can be made object not instance based. But still, the model has many flaws. Over the course of the years many solutions have been proposed, for example <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html">EASTL</a>. This library is another. But instead of trying to change the STL, it works with the current implementation.</p>
<p>If you like this project, consider <a href="https://jonathanmueller.dev/support-me/">supporting me</a>. It would really help!</p>
<h1><a class="anchor" id="autotoc_md79"></a>
Features</h1>
<p>New allocator concepts:</p>
<ul>
<li>a <code>RawAllocator</code> that is similar to an <code>Allocator</code> but easier to use and write</li>
<li>a <code>BlockAllocator</code> that is an allocator for huge memory blocks</li>
</ul>
<p>Several implementations:</p>
<ul>
<li><code>heap_/malloc_/new_allocator</code></li>
<li>virtual memory allocators</li>
<li>allocator using a static memory block located on the stack</li>
<li>memory stack, <code>iteration_allocator</code></li>
<li>different memory pools</li>
<li>a portable, improved <code>alloca()</code> in the form of <code>temporary_allocator</code></li>
<li>facilities for joint memory allocations: share a big memory block for the object and all dynamic memory allocations for its members</li>
</ul>
<p>Adapters, wrappers and storage classes:</p>
<ul>
<li>incredible powerful <code>allocator_traits</code> allowing <code>Allocator</code>s as <code>RawAllocator</code>s</li>
<li><code>std_allocator</code> to make a <code>RawAllocator</code> an <code>Allocator</code> again</li>
<li>adapters for the memory resource TS</li>
<li><code>allocator_deleter</code> classes for smart pointers</li>
<li>(optionally type-erased) <code>allocator_reference</code> and other storage classes</li>
<li>memory tracking wrapper</li>
</ul>
<p>In addition:</p>
<ul>
<li>container node size debuggers that obtain information about the node size of an STL container at compile-time to specify node sizes for pools</li>
<li>debugging options for leak checking, double-free checks or buffer overflows</li>
<li>customizable error handling routines that can work with exceptions disabled</li>
<li>everything except the STL adapters works on a freestanding environment</li>
</ul>
<h1><a class="anchor" id="autotoc_md80"></a>
Basic example</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="container_8hpp.html">foonathan/memory/container.hpp</a>&gt;</span> <span class="comment">// vector, list, list_node_size</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory__pool_8hpp.html">foonathan/memory/memory_pool.hpp</a>&gt;</span> <span class="comment">// memory_pool</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="smart__ptr_8hpp.html">foonathan/memory/smart_ptr.hpp</a>&gt;</span> <span class="comment">// allocate_unique</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="static__allocator_8hpp.html">foonathan/memory/static_allocator.hpp</a>&gt;</span> <span class="comment">// static_allocator_storage, static_block_allocator</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="temporary__allocator_8hpp.html">foonathan/memory/temporary_allocator.hpp</a>&gt;</span> <span class="comment">// temporary_allocator</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// alias namespace foonathan::memory as memory for easier access</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="namespace__alias_8hpp.html">foonathan/memory/namespace_alias.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BiIter&gt;</div>
<div class="line"><span class="keywordtype">void</span> merge_sort(BiIter begin, BiIter end);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>memory::literals;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// a memory pool RawAllocator</span></div>
<div class="line">    <span class="comment">// allocates a memory block - initially 4KiB - and splits it into chunks of list_node_size&lt;int&gt;::value big</span></div>
<div class="line">    <span class="comment">// list_node_size&lt;int&gt;::value is the size of each node of a std::list</span></div>
<div class="line">    memory::memory_pool&lt;&gt; pool(<a class="code" href="structfoonathan_1_1memory_1_1list__node__size.html">memory::list_node_size&lt;int&gt;::value</a>, 4_KiB);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// just an alias for std::list&lt;int, memory::std_allocator&lt;int, memory::memory_pool&lt;&gt;&gt;</span></div>
<div class="line">    <span class="comment">// a std::list using a memory_pool</span></div>
<div class="line">    <span class="comment">// std_allocator stores a reference to a RawAllocator and provides the Allocator interface</span></div>
<div class="line">    <a class="code" href="classfoonathan_1_1memory_1_1list.html">memory::list&lt;int, memory::memory_pool&lt;&gt;</a>&gt; list(pool);</div>
<div class="line">    list.push_back(3);</div>
<div class="line">    list.push_back(2);</div>
<div class="line">    list.push_back(1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : list)</div>
<div class="line">        std::cout &lt;&lt; e &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">    merge_sort(list.begin(), list.end());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : list)</div>
<div class="line">        std::cout &lt;&lt; e &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// allocate a std::unique_ptr using the pool</span></div>
<div class="line">    <span class="comment">// memory::allocate_shared is also available</span></div>
<div class="line">    <span class="keyword">auto</span> ptr = memory::allocate_unique&lt;int&gt;(pool, *list.begin());</div>
<div class="line">    std::cout &lt;&lt; *ptr &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// static storage of size 4KiB</span></div>
<div class="line">    <a class="code" href="structfoonathan_1_1memory_1_1static__allocator__storage.html">memory::static_allocator_storage&lt;4096u&gt;</a> storage;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// a memory pool again but this time with a BlockAllocator</span></div>
<div class="line">    <span class="comment">// this controls the internal allocations of the pool itself</span></div>
<div class="line">    <span class="comment">// we need to specify the first template parameter giving the type of the pool as well</span></div>
<div class="line">    <span class="comment">// (node_pool is the default)</span></div>
<div class="line">    <span class="comment">// we use a static_block_allocator that uses the static storage above</span></div>
<div class="line">    <span class="comment">// all allocations will use a memory block on the stack</span></div>
<div class="line">    <span class="keyword">using</span> static_pool_t = memory::memory_pool&lt;memory::node_pool, memory::static_block_allocator&gt;;</div>
<div class="line">    static_pool_t static_pool(<a class="code" href="structfoonathan_1_1memory_1_1unordered__set__node__size.html">memory::unordered_set_node_size&lt;int&gt;::value</a>, 4096u, storage);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// again, just an alias for std::unordered_set&lt;int, std::hash&lt;int&gt;, std::equal_to&lt;int&gt;, memory::std_allocator&lt;int, static_pool_t&gt;</span></div>
<div class="line">    <span class="comment">// see why I wrote these? :D</span></div>
<div class="line">    <span class="comment">// now we have a hash set that lives on the stack!</span></div>
<div class="line">    <a class="code" href="classfoonathan_1_1memory_1_1unordered__set.html">memory::unordered_set&lt;int, static_pool_t&gt;</a> set(static_pool);</div>
<div class="line"> </div>
<div class="line">    set.insert(3);</div>
<div class="line">    set.insert(2);</div>
<div class="line">    set.insert(3); <span class="comment">// running out of stack memory is properly handled, of course</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : set)</div>
<div class="line">        std::cout &lt;&lt; e &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// naive implementation of merge_sort using temporary memory allocator</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BiIter&gt;</div>
<div class="line"><span class="keywordtype">void</span> merge_sort(BiIter begin, BiIter end)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> std::iterator_traits&lt;BiIter&gt;::value_type;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> distance = std::distance(begin, end);</div>
<div class="line">    <span class="keywordflow">if</span> (distance &lt;= 1)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> mid = begin;</div>
<div class="line">    std::advance(mid, distance / 2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// an allocator for temporary memory</span></div>
<div class="line">    <span class="comment">// is similar to alloca() but uses its own stack</span></div>
<div class="line">    <span class="comment">// this stack is thread_local and created on the first call to this function</span></div>
<div class="line">    <span class="comment">// as soon as the allocator object goes out of scope, everything allocated through it, will be freed</span></div>
<div class="line">    <span class="keyword">auto</span> alloc = memory::make_temporary_allocator();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// alias for std::vector&lt;value_type, memory::std_allocator&lt;value_type, memory::temporary_allocator&gt;&gt;</span></div>
<div class="line">    <span class="comment">// a std::vector using a temporary_allocator</span></div>
<div class="line">    <a class="code" href="classfoonathan_1_1memory_1_1vector.html">memory::vector&lt;value_type, memory::temporary_allocator&gt;</a> first(begin, mid, alloc),</div>
<div class="line">                                                            second(mid, end, alloc);</div>
<div class="line"> </div>
<div class="line">    merge_sort(first.begin(), first.end());</div>
<div class="line">    merge_sort(second.begin(), second.end());</div>
<div class="line">    std::merge(first.begin(), first.end(), second.begin(), second.end(), begin);</div>
<div class="line">}</div>
</div><!-- fragment --><p>See <code>example/</code> for more.</p>
<h1><a class="anchor" id="autotoc_md81"></a>
Installation</h1>
<p>This library can be used as <a href="www.cmake.org">CMake</a> subdirectory. It is tested on GCC 4.8-5.0, Clang 3.5 and Visual Studio 2013. Newer versions should work too.</p>
<ol type="1">
<li>Fetch it, e.g. using <a href="http://git-scm.com/docs/git-submodule">git submodules</a> <code>git submodule add <a href="https://github.com/foonathan/memory">https://github.com/foonathan/memory</a> ext/memory</code> and <code>git submodule update --init --recursive</code>.</li>
<li>Call <code>add_subdirectory(ext/memory)</code> or whatever your local path is to make it available in CMake.</li>
<li>Simply call <code>target_link_libraries(your_target PUBLIC foonathan_memory)</code> to link this library and setups the include search path and compilation options.</li>
</ol>
<p><em>Note: If during CMake you see an error message that compatibility is not on the newest version, run <code>git submodule update --recursive --remote</code> to force the compatiblity submodule of memory to update to the latest version.</em></p>
<p>You can also install the library:</p>
<ol type="1">
<li>Run <code>cmake -DCMAKE_BUILD_TYPE="buildtype" -DFOONATHAN_MEMORY_BUILD_EXAMPLES=OFF -DFOONATHAN_MEMORY_BUILD_TESTS=OFF .</code> inside the library sources.</li>
<li>Run <code>cmake --build . -- install</code> to install the library under <code>${CMAKE_INSTALL_PREFIX}</code>.</li>
<li>Repeat 1 and 2 for each build type/configuration you want to have (like <code>Debug</code>, <code>RelWithDebInfo</code> and <code>Release</code> or custom names).</li>
</ol>
<p>To use an installed library:</p>
<ol type="1">
<li>Call <code>find_package(foonathan_memory major.minor REQUIRED)</code> to find the library.</li>
<li>Call <code>target_link_libraries(your_target PUBLIC foonathan_memory)</code> to link to the library and setup all required options.</li>
</ol>
<p>See <a href="https://foonathan.net/memory/md_doc_installation.html">https://foonathan.net/memory/md_doc_installation.html</a> for a detailed guide.</p>
<h1><a class="anchor" id="autotoc_md82"></a>
Documentation</h1>
<p>Full documentation can be found at <a href="https://foonathan.net/memory">https://foonathan.net/memory</a>.</p>
<p>A tutorial is also available at <a href="https://foonathan.net/memory/md_doc_tutorial.html">https://foonathan.net/memory/md_doc_tutorial.html</a>.</p>
<h1><a class="anchor" id="autotoc_md83"></a>
RawAllocator</h1>
<p>Below is the interface required for a <code>RawAllocator</code>, everything optional is marked:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>raw_allocator</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> is_stateful = std::integral_constant&lt;bool, Value&gt;; <span class="comment">// optional, defaults to std::is_empty</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* allocate_node(std::size_t size, std::size_t alignment); <span class="comment">// required, allocation function</span></div>
<div class="line">    <span class="keywordtype">void</span> deallocate_node(<span class="keywordtype">void</span> *node, std::size_t size, std::size_t alignment) noexcept; <span class="comment">// required, deallocation function</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* allocate_array(std::size_t count, std::size_t size, std::size_t alignment); <span class="comment">// optional, forwards to node version</span></div>
<div class="line">    <span class="keywordtype">void</span> deallocate_array(<span class="keywordtype">void</span> *ptr, std::size_t count, std::size_t size, std::size_t alignment) noexcept; <span class="comment">// optional, forwards to node version</span></div>
<div class="line"> </div>
<div class="line">    std::size_t max_node_size() <span class="keyword">const</span>; <span class="comment">// optional, returns maximum value</span></div>
<div class="line">    std::size_t max_array_size() <span class="keyword">const</span>; <span class="comment">// optional, forwards to max_node_size()</span></div>
<div class="line">    std::size_t max_alignment() <span class="keyword">const</span>; <span class="comment">// optional, returns maximum fundamental alignment, i.e. alignof(std::max_align_t)</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>A <code>RawAllocator</code> only needs to be moveable, all <code>Allocator</code> classes are <code>RawAllocators</code> too. Classes not providing the interface can specialize the <code>allocator_traits</code>, read more about <a href="https://foonathan.net/memory/md_doc_writing_allocators.html">writing allocators here</a> or about the technical details of the <a href="https://foonathan.net/memory/md_doc_concepts.html">concept here</a>.</p>
<h1><a class="anchor" id="autotoc_md84"></a>
Acknowledgements</h1>
<p>This project is greatly supported by my <a href="https://patreon.com/foonathan">patrons</a>. In particular thanks to the individual supporters:</p>
<ul>
<li>Kaido Kert</li>
</ul>
<p>And big thanks to the contributors as well:</p>
<ul>
<li>@bfierz</li>
<li>@nicolastagliani</li>
<li>@cho3</li>
<li>@myd7349</li>
<li>@moazzamak</li>
<li>@maksqwe</li>
<li>@kaidokert</li>
<li>@gabyx</li>
<li>@MiguelCompany</li>
<li>@Manu343726 </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclassfoonathan_1_1memory_1_1vector_html"><div class="ttname"><a href="classfoonathan_1_1memory_1_1vector.html">foonathan::memory::vector</a></div><div class="ttdoc">Alias template for an STL container that uses a certain RawAllocator.</div><div class="ttdef"><b>Definition:</b> container.hpp:47</div></div>
<div class="ttc" id="anamespace__alias_8hpp_html"><div class="ttname"><a href="namespace__alias_8hpp.html">namespace_alias.hpp</a></div></div>
<div class="ttc" id="astructfoonathan_1_1memory_1_1list__node__size_html"><div class="ttname"><a href="structfoonathan_1_1memory_1_1list__node__size.html">foonathan::memory::list_node_size</a></div><div class="ttdoc">Contains the node size of a node based STL container with a specific type.</div><div class="ttdef"><b>Definition:</b> container.hpp:288</div></div>
<div class="ttc" id="aclassfoonathan_1_1memory_1_1list_html"><div class="ttname"><a href="classfoonathan_1_1memory_1_1list.html">foonathan::memory::list</a></div><div class="ttdoc">Alias template for an STL container that uses a certain RawAllocator.</div><div class="ttdef"><b>Definition:</b> container.hpp:67</div></div>
<div class="ttc" id="atemporary__allocator_8hpp_html"><div class="ttname"><a href="temporary__allocator_8hpp.html">temporary_allocator.hpp</a></div></div>
<div class="ttc" id="aclassfoonathan_1_1memory_1_1unordered__set_html"><div class="ttname"><a href="classfoonathan_1_1memory_1_1unordered__set.html">foonathan::memory::unordered_set</a></div><div class="ttdoc">Alias template for an STL container that uses a certain RawAllocator.</div><div class="ttdef"><b>Definition:</b> container.hpp:135</div></div>
<div class="ttc" id="astructfoonathan_1_1memory_1_1static__allocator__storage_html"><div class="ttname"><a href="structfoonathan_1_1memory_1_1static__allocator__storage.html">foonathan::memory::static_allocator_storage</a></div><div class="ttdoc">Storage for a static_allocator.</div><div class="ttdef"><b>Definition:</b> static_allocator.hpp:33</div></div>
<div class="ttc" id="astatic__allocator_8hpp_html"><div class="ttname"><a href="static__allocator_8hpp.html">static_allocator.hpp</a></div></div>
<div class="ttc" id="asmart__ptr_8hpp_html"><div class="ttname"><a href="smart__ptr_8hpp.html">smart_ptr.hpp</a></div></div>
<div class="ttc" id="acontainer_8hpp_html"><div class="ttname"><a href="container_8hpp.html">container.hpp</a></div></div>
<div class="ttc" id="astructfoonathan_1_1memory_1_1unordered__set__node__size_html"><div class="ttname"><a href="structfoonathan_1_1memory_1_1unordered__set__node__size.html">foonathan::memory::unordered_set_node_size</a></div><div class="ttdoc">Contains the node size of a node based STL container with a specific type.</div><div class="ttdef"><b>Definition:</b> container.hpp:306</div></div>
<div class="ttc" id="amemory__pool_8hpp_html"><div class="ttname"><a href="memory__pool_8hpp.html">memory_pool.hpp</a></div></div>
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
